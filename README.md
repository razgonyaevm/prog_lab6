# Лабораторная работа №7

## Вариант `13586`

Доработать программу из лабораторной работы №6 следующим образом:

1. Организовать хранение коллекции в реляционной СУБД (PostgresQL). Убрать хранение коллекции в файле.
2. Для генерации поля id использовать средства базы данных (sequence).
3. Обновлять состояние коллекции в памяти только при успешном добавлении объекта в БД
4. Все команды получения данных должны работать с коллекцией в памяти, а не в БД
5. Организовать возможность регистрации и авторизации пользователей. У пользователя есть возможность указать пароль.
6. Пароли при хранении хэшировать алгоритмом `MD5`
7. Запретить выполнение команд не авторизованным пользователям.
8. При хранении объектов сохранять информацию о пользователе, который создал этот объект.
9. Пользователи должны иметь возможность просмотра всех объектов коллекции, но модифицировать могут только принадлежащие
   им.
10. Для идентификации пользователя отправлять логин и пароль с каждым запросом.

Необходимо реализовать многопоточную обработку запросов.

1. Для многопоточного чтения запросов использовать `создание нового потока (java.lang.Thread)`
2. Для многопотчной обработки полученного запроса использовать `создание нового потока (java.lang.Thread)`
3. Для многопоточной отправки ответа использовать `ForkJoinPool`
4. Для синхронизации доступа к коллекции использовать `синхронизацию чтения и записи с помощью
   java.util.concurrent.locks.ReentrantLock`

**Порядок выполнения работы:**

1. В качестве базы данных использовать PostgreSQL.
2. Для подключения к БД на кафедральном сервере использовать хост `pg`, имя базы данных - `studs`, имя
   пользователя/пароль совпадают с таковыми для подключения к серверу.

**Вопросы к защите лабораторной работы:**

1. Многопоточность. Класс `Thread`, интерфейс `Runnable`. Модификатор `synchronized`.
2. Методы `wait()`, `notify()` класса `Object`, интерфейсы `Lock` и `Condition`.
3. Классы-сихронизаторы из пакета `java.util.concurrent`.
4. Модификатор `volatile`. Атомарные типы данных и операции.
5. Коллекции из пакета `java.util.concurrent`.
6. Интерфейсы `Executor`, `ExecutorService`, `Callable`, `Future`
7. Пулы потоков
8. JDBC. Порядок взаимодействия с базой данных. Класс `DriverManager`. Интерфейс `Connection`
9. Интерфейсы `Statement`, `PreparedStatement`, `ResultSet`, `RowSet`
10. Шаблоны проектирования.

---

# Лабораторная работа №6

## Вариант `10527`

| code              | javadoc                                       | server              | client              |
|-------------------|-----------------------------------------------|---------------------|---------------------|
| [code](./common/) | [javadoc](https://razgonyaevm.github.io/lab5) | [server](./server/) | [client](./client/) |

Разделить программу из лабораторной работы №5 на клиентский и серверный модули. Серверный модуль должен осуществлять
выполнение команд по управлению коллекцией. Клиентский модуль должен в интерактивном режиме считывать команды,
передавать их для выполнения на сервер и выводить результаты выполнения.

***

### Необходимо выполнить следующие требования:

* Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
* Объекты между клиентом и сервером должны передаваться в сериализованном виде.
* Объекты в коллекции, передаваемой клиенту, должны быть отсортированы по умолчанию
* Клиент должен корректно обрабатывать временную недоступность сервера.
* Обмен данными между клиентом и сервером должен осуществляться по протоколу UDP
* Для обмена данными на сервере необходимо использовать **сетевой канал**
* Для обмена данными на клиенте необходимо использовать **датаграммы**
* Сетевые каналы должны использоваться в неблокирующем режиме.

***

### Обязанности серверного приложения:

* Работа с файлом, хранящим коллекцию.
* Управление коллекцией объектов.
* Назначение автоматически генерируемых полей объектов в коллекции.
* Ожидание подключений и запросов от клиента.
* Обработка полученных запросов (команд).
* Сохранение коллекции в файл при завершении работы приложения.
* Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду
  отправить не может).

***

### Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):

* Модуль приёма подключений.
* Модуль чтения запроса.
* Модуль обработки полученных команд.
* Модуль отправки ответов клиенту.

Сервер должен работать в **однопоточном** режиме.

***

### Обязанности клиентского приложения:

* Чтение команд из консоли.
* Валидация вводимых данных.
* Сериализация введённой команды и её аргументов.
* Отправка полученной команды и её аргументов на сервер.
* Обработка ответа от сервера (вывод результата исполнения команды в консоль).
* Команду `save` из клиентского приложения необходимо убрать.
* Команда `exit` завершает работу клиентского приложения.

Важно! Команды и их аргументы должны представлять из себя объекты классов. Недопустим обмен "простыми" строками. Так,
для команды add или её аналога необходимо сформировать объект, содержащий тип команды и объект, который должен храниться
в вашей коллекции.

***

### Дополнительное задание:

Реализовать логирование различных этапов работы сервера (начало работы, получение нового подключения, получение нового
запроса, отправка ответа и т.п.) с помощью **Log4J2**

***

### Отчёт по работе должен содержать:

1. Текст задания.
2. Диаграмма классов разработанной программы (как клиентского, так и серверного приложения).
3. Исходный код программы.
4. Выводы по работе.

***

### Вопросы к защите лабораторной работы:

1. Сетевое взаимодействие - клиент-серверная архитектура, основные протоколы, их сходства и отличия.
2. Протокол TCP. Классы `Socket` и `ServerSocket`.
3. Протокол UDP. Классы `DatagramSocket` и `DatagramPacket`.
4. Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. Работа с сетевыми каналами.
5. Классы `SocketChannel` и `DatagramChannel`.
6. Передача данных по сети. Сериализация объектов.
7. Интерфейс `Serializable`. Объектный граф, сериализация и десериализация полей и методов.
8. Java Stream API. Создание конвейеров. Промежуточные и терминальные операции.
9. Шаблоны проектирования: Decorator, Iterator, Factory method, Command, Flyweight, Interpreter, Singleton, Strategy,
   Adapter, Facade, Proxy.